package main

import (
	"context"
	"runtime"
	"time"
)

/*
Первый и самый простой способ - написать ключевое слово return,
тем самым мы выйдем из функции и "завершим" горутину
*/
func option1() {
	// какой-то код
	return
}

/*
Второй способ - это вызвать функцию Goexit. Она экстренно завершит текущую горутину.
Её лучше не использовать в main-функции(схватим дедлок), но так сделать возможно,
в таком случае мы дождёмся завершения остальных горутин, вызванных в мейне и схватим дедлок
*/
func option2() {
	// Какой-то код
	runtime.Goexit()
}

/*
Третий способ использует каналы для завершения горутины.
В цикле постоянно идёт ожидание данных в канале, и когда они приходят - горутина завершается
*/
func option3(stopChan chan struct{}) {
	// Какой-то код
	for {
		select {
		case <-stopChan:
			// Тут можно выполнить необходимые действия перед остановкой
			return
		default:
			// Какой-то другой код
		}
	}
}

/*
В четвёртом варианте мы используем "контекст с отменой".
Когда вызывается функция cancel, то закрывается канал Done и мы обрабатываем этот случай
*/
func option4(ctx context.Context) {
	// Какой-то код
	for {
		select {
		case <-ctx.Done():
			// Тут можно выполнить необходимые действия перед остановкой
			return
		default:
			// Какой-то другой код
		}
	}
}

func main() {
	// Вариант 1
	go option1()

	// Вариант 2
	go option2()

	// Вариант 3
	stopChan := make(chan struct{})
	go option3(stopChan)

	stopChan <- struct{}{} // Для остановки горутины отправляем какое-нибудь значение

	// Вариант 4
	ctx, cancel := context.WithCancel(context.Background())
	go option4(ctx)

	cancel() // Для остановки горутины вызываем cancel

	// Имитация ожидания горутин
	time.Sleep(2 * time.Second)
}
